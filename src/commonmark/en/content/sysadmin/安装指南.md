# 安装与部署

<!--DHIS2-SECTION-ID:installation-->

本节介绍系统安装部署的相关信息，包括：在线中央服务器, 离线内网安装, 本地单机版和用于演示的docker版。

## 介绍

<!--DHIS2-SECTION-ID:install_introduction-->

本系统可以运行在所有安装了Java运行时（JRE8或理高版本）的平台上，包括Windows, Linux 和 Mac. 同时使用 PostgreSQL作为其数据库。发布的系统打包为标准的Java Web Archive(WAR包)，所以可以在任何Servlet 容器上运行，比如 Tomcat 和 Jetty。

推荐使用 Ubuntu 16.04 LTS 操作系统、PostgreSQL数据库、Tomcat Servlet 容器作为首选软件环境。

This chapter provides a guide for setting up the above technology stack.
It should however be read as a guide for getting up and running and not
as an exhaustive documentation for the mentioned environment. We refer
to the official Ubuntu, PostgreSQL and Tomcat documentation for in-depth
reading.

The dhis2-tools Ubuntu package automates many of the tasks described in
the guide below and is recommended for most users, especially those who
are not familiar with the command line or administration of servers. It
is described in detail in a separate chapter in this guide.

## 服务器硬件要求

<!--DHIS2-SECTION-ID:install_server_specifications-->

DHIS2 is a database intensive application and requires that your server
has an appropriate amount of RAM, number of CPU cores and a fast disk.
These recommendations should be considered as rules-of-thumb and not
exact measures. DHIS2 scales linearly on the amount of RAM and number of
CPU cores so the more you can afford, the better the application will
perform.

  - 内存: At least 1 GB memory per 1 million captured data records per
    month or per 1000 concurrent users. At least 4 GB for a small
    instance, 12 GB for a medium instance.

  - CPU 核心数: 4 CPU cores for a small instance, 8 CPU cores for a
    medium or large instance.

  - 硬盘: Ideally use an SSD. Otherwise use a 7200 rpm disk. Minimum
    read speed is 150 Mb/s, 200 Mb/s is good, 350 Mb/s or better is
    ideal. In terms of disk space, at least 60 GB is reccomended, but
    will depend entirely on the amount of data which is contained in the
    data value tables. Analytics tables require a significant amount of
    disk space. Plan ahead and ensure that your server can be upgraded
    with more disk space as it becomes needed.

## 软件环境要求

<!--DHIS2-SECTION-ID:install_software_requirements-->

Later DHIS2 versions require the following software versions to operate.

  - Java JRE version 8 或更高版本

  - Any operating system for which a Java JRE version 8 exists.

  - PostgreSQL 数据库 version 9.6 或更高版本

  - PostGIS 数据库扩展 version 2.2 或更高版本

  - Tomcat servlet 容器 version 8 或更高版本, 或其它 Servlet API
    3.1 compliant servlet 容器，如 Jetty 9.

## 部署服务器

<!--DHIS2-SECTION-ID:install_server_setup-->

本节介绍如何在Ubuntu 16.04 64 bit 操作系统上安装DHIS2，以PostgreSQL作为数据库、Tomcat 作为Servlet 容器。
 This guide is not meant to be a step-by-step guide
per se, but rather to serve as a reference to how DHIS2 can be deployed
on a server. There are many possible deployment strategies, which will
differ depending on the operating system and database you are using, and
other factors. The term *invoke* refers to executing a given command in
a terminal.

For a national server the recommended configuration is a quad-core 2 Ghz
processor or higher and 12 Gb RAM or higher. Note that a 64 bit
operating system is required for utilizing more than 4 Gb of RAM.

For this guide we assume that 8 Gb RAM is allocated for PostgreSQL and 8
GB RAM is allocated for Tomcat/JVM, and that a 64-bit operating system
is used. *If you are running a different configuration please adjust the
suggested values accordingly\!* We recommend that the available memory
is split roughly equally between the database and the JVM. Remember to
leave some of the physical memory to the operating system for it to
perform its tasks, for instance around 2 GB. The steps marked as
*optional*, like the step for performance tuning, can be done at a later
stage.

### 为运行DHIS2创建一个用户

<!--DHIS2-SECTION-ID:install_creating_user-->

为运行DHIS2，你需要创建一个DHIS2专用的用户。
使用以下命令为操作系统新增一个名为ubuntu_dhis2的用户，并将路径/home/dhis2设置成此用户的用户目录:

    sudo useradd -d /home/dhis2 -m ubuntu_dhis2 -s /bin/false

> **注意**
>
> You should not run the DHIS2 server as a privileged user such as root.

为此用户设置密码:

    sudo passwd ubuntu_dhis2

建设使用15位以上的混合字串作为强密码。

### 创建配置目录

<!--DHIS2-SECTION-ID:install_creating_config_directory-->

在DHIS2用户目录下创建DHIS2配置文件所需的目录，相关app、文件、日志都将使用此目录：

    mkdir /home/dhis2/config

此目录的所有权授给用户ubuntu_dhis2和dhis用户组：

    chown ubuntu_dhis2:ubuntu_dhis2 /home/dhis2/config

DHIS2程序将搜寻名为*DHIS2\_HOME* 的环境变量来定位其配置文件的所在目录。所以刚刚创建的目录需要被指向到*DHIS2\_HOME* 环境变量。环境变量的定义将在后续步骤介绍。

### 设置服务器时区和地区

<!--DHIS2-SECTION-ID:install_setting_server_tz-->

It may be necessary to reconfigure the time zone of the server to match
the time zone of the location which the DHIS2 server will be covering.
If you are using a  private server, the default time zone may not
correspond to the time zone of your DHIS2 location. You can easily
reconfigure the time zone by invoking the below and following the
instructions.设置时区：

    sudo dpkg-reconfigure tzdata

PostgreSQL 是区分地区语言编码的，所以需要设置成你所在的地区。先查看系统已存在的地区，然后设置为中文：

    locale -a
    sudo locale-gen zh_CN.utf8

### 安装 PostgreSQL 数据库

<!--DHIS2-SECTION-ID:install_postgresql_installation-->

#### 准备工作：
1、将apt-get的在线源改为国内镜像，参考：https://developer.aliyun.com/mirror/ubuntu
2、添加PostgreSQL安装源，通过在 /etc/apt/sources.list.d/中增加一个文件pgdg.list

```sh
sudo touch /etc/apt/sources.list.d/pgdg.list
sudo vi /etc/apt/sources.list.d/pgdg.list
```
并在pgdg.list的内容如下：
	deb http://apt.postgresql.org/pub/repos/apt/ xenial-pgdg main

执行写入凭证命令后更新源：

```sh
wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -

sudo apt-get update
```

#### 在线安装与数据库基础配置
    
	sudo apt-get install postgresql-12 postgresql-contrib-12 postgresql-12-postgis-3


使用postgres用户登录登陆（安装PostgreSQL时安装程序添加了一个名用postgres的用户，由于因为没有配置环境，所以对数据库的操作不用使用root用户，而需要用此数据库用户登陆：sudo -u postgres），并为数据库创建一个名为 *postgres_dhis* 的非特权用户:

    sudo -u postgres createuser -SDRP postgres_dhis

设置密码后，利用postgres_dhis用户新建一个库文件，名为dhis2db：

    sudo -u postgres createdb -O postgres_dhis dhis2db

使用postgres用户尝试连接到刚刚创建的dhis2db数据库：

	sudo -u postgres psql dhis2db

运行命令后若终端提示末行显示“dhis2db=#”则说明成功连接到数据库了。
可以通过输入 `exit` 命令退出数据库并返回系统的bush shell。
目前为止，你拥有了一个名个*postgres_dhis*的PostgreSQL用户和一个名为*dhis2db*的数据库。
虽然我们通过操作系统超级用户身份使用数据库内置postgres用户在本机成功的免密码登陆了数据库，但还需要设置网络登陆：

1、修改*/etc/postgresql/12/main/postgresql.conf*配置文件中的*# listen_addresses = 'localhost'* 修改为 *listen_addresses = '*' *
其中*号代表允许任意IP地址连接数据库。可以是指定的具体的IP白名单，用“,”逗号分隔。

2、修改PostgreSQL的认证配置文件*/etc/postgresql/12/main/pg_hba.conf*，
找到其中*IPv4 local connections:*行，将其*ADDRESS*列对应的值：*127.0.0.1/32*修改为 *0.0.0.0/0* （允许全部网段，生产环境请根据实际情况修改）

3、修改/home/dhis2/config/dhis.conf 配置文件中的connection.url = jdbc:postgresql:dhis2//IP地址:5432/dhis2db

设置完毕，重启数据库服务：

	sudo service postgresql restart
	
现在可以使用任意数据库客户端通过网络连接数据库了。推荐使用 pgAdmin 4，下载地址：https://www.pgadmin.org/download/

用户postgres的默认密码是安装PostgreSQL时随机生成的，可以通过以下命令更改密码：
> ```sh
> sudo -u postgres psql -d template1 -c "ALTER USER postgres WITH PASSWORD '新密码';"
> ```
>


*PostGIS* 扩展用于几个GIS地图相关的特性。DHIS 2程序会在启动过程中尝试安装PostGIS扩展。
如果DHIS 2的数据库用户*postgres_dhis*没有创建扩展的权限，则可以通过*postgres*用户执行以下语句为dhis2db库提前创建postgis扩展：

    sudo -u postgres psql -c "create extension postgis;" dhis2db

控制台打印出“CREATE EXTENSION”则表示成功。

### PostgreSQL 性能调优

<!--DHIS2-SECTION-ID:install_postgresql_performance_tuning-->

虽然让DHIS2运行起来并不需要对PostgreSQL进行性能调优，但为了使系统高效运转性能调优则是必需的。 可能利用以下命令来配置*postgresql.conf* 文件，从而完成PostgreSQL的配置和调优：

    sudo nano /etc/postgresql/12/main/postgresql.conf

> **小技巧**
> 
> 在nano编辑器中可以使用*Ctrl + W*键进行快速搜索并定位关键字。
> 

更改以下属性：

1、指定PostgreSQL允许的最大连接数（在并发量的大环境下建议设置为300）:

    max_connections = 300

2、指定PostgreSQL缓存要独占的内存大小。它表示数据缓冲区中的数据块的个数，并决定有多少内存可以被PostgreSQL用于缓存数据。
在IO压力很大的情况下，提高该值可以减少IO，推荐设置为PostgreSQL专用内存总量的40%左右，或设置为服务器总内存的1/4。

    shared_buffers = 3200MB

3、指定需要为PostgreSQL保留的核心共享内存，内部排序和一些复杂的查询都在这个buffer中完成，提高其值有助提高排序等操作的速度，并且减低IO。
它决定用于内部排序和哈希操作的内存量。如果work_mem指定的内存被耗尽，数据库将使用磁盘文件进行完成操作，速度会慢很多。
ORDER BY、DISTINCT和merge连接都会使用排序操作，哈希表在Hash连接、hash聚集函数和用哈希表来处理IN谓词中的子查询中被使用。

    work_mem = 20MB

> **警告**
> 
> 虽然work_mem值的大小将对DHIS2的聚合性能造成关键影响。
> 但是由于此设置将对每个连接、每次查询生效，所以又不能将其实设置得太高。
>

4、指定耗费资源较多的命令调用时使用的内存。把该值调大，能加快命令的执行。
此参数可以在任何时候被设置。它决定数据库的维护操作使用的内存空间的大小。数据库的维护操作包括VACUUM、CREATE INDEX和ALTER TABLE ADD FOREIGN KEY等操作。 
maintenance_work_mem的值如果比较大，通常可以缩短VACUUM数据库和从dump文件中恢复数据库需要的时间。maintenance_work_mem存放在每个数据库进程的私有内存中，而不是存放在数据库的共享内存中。
此设置分配的内存主要用于PostgreSQL的维护操作，如：创建索引、运行清理、添加外键等。它将对DHIS2在分析生成过程中创建索引的性能造成影响。

    maintenance_work_mem = 512MB

5、设置单个查询可以使用的数据缓冲区的大小。这是优化器假设一个查询可以用的最大内存。可以设置为较大，16G内存以上的独立数据库服务器推荐设置为内存的1/2，因为优化器更倾向使用索引扫描而不是顺序扫描。

    effective_cache_size = 8000MB

> **注意**
> 
> 将*effective_cache_size*设置为比实际可用值更高的值会影响性能。
> *effective_cache_size*的值应将*shared_buffers*设置的值包含在内。
> PostgreSQL有两层缓存：第一层使用内核共享内存，由*shared_buffers*设置控制。PostgreSQL将第二层委托给操作系统磁盘缓存，可用内存的大小由*effective_cache_size*设置控制。
>

6、这个参数控制检查点操作的执行时间。取值在0到1之间，默认值是0.5。表示checkpoint的完成时间要在两个checkpoint间隔时间的N%内完成，优化此参数能降低平均写入的开销。

    checkpoint_completion_target = 0.8

> **提示**
> 
> 此设置会影响WAL写入数据库日志过程中用于缓冲的内存。增加这个值可能会提高写繁重系统的吞吐量。
>

7、指定事务提交是否在返回到客户端之前等待将WAL日志记录写入磁盘。将此设置为禁用将显著提高性能，因为写到缓存中就会向客户端返回提交成功，延迟写入磁盘。
延迟的时间为最大3倍的wal_writer_delay参数的(下面将设置成1000ms)的时间,所有如果即使关闭synchronous_commit,也只会造成最多3s的事务丢失,此事务甚至包括已经提交的事务（会丢数据）,但数据库确可以安全启动,不会发生块折断,只是丢失了部分数据,但对高并发的小事务系统来说,性能来说提升较大。这对于像DHIS2这样的性能密集型和写繁重的系统是一个很好的选择。

    synchronous_commit = off

8、指定WAL-write操作之间的延迟，它决定写事务日志进程的睡眠时间，即每隔多长时间进行一次写操作。
WAL进程每次在完成写事务日志的任务后，就会睡眠wal_writer_delay指定的时间，然后醒来，继续将新产生的事务日志从缓冲区写到WAL文件中。
将此值设置为高值将提高写繁重系统的性能，因为可能有许多写操作可以在单个磁盘刷新中执行。

    wal_writer_delay = 10000ms

9、设置从数据文件上随机读取一个数据块的执行成本。设置查询计划器对非顺序获取的磁盘页的成本估计。较低的值将导致系统更喜欢索引扫描而不是顺序扫描。
对于在SSD上运行或在内存中大缓存的数据库，低值是有意义的。默认值为4.0，这对于传统磁盘来说是合理的。

	random_page_cost = 1.1

> **提示**
> 
> 仅当数据库使用*SSD*硬盘时闭将设置此属性值为*1.1*。
>

10、指定为每个事务分配的对象锁的平均数。数据库在启动以后创建的共享锁表最大可以保存的对象锁数量为：
max_locks_per_transaction * (max_connections + max_prepared_transactions)个。
单个事务可以同时获得的对象锁的数目可以超过max_locks_per_transaction的值，只要共享锁表中还有剩余空间。每个锁占用270个字节的共享内存。
在DHIS2中执行定时任务时将大量的表加载到内存中，此项设置将对其造成影响。

    max_locks_per_transaction = 96


> **提示**
> 
> 若不修改max_locks_per_transaction的值，DHIS2在启动时会提示数据库初始值小。
> 但由于此设置会影响内存的占用，故具体设置视服务器硬件而定。
> 

重启数据库服务以使设置生效：

```sh
sudo /etc/init.d/postgresql restart
```

### DHIS2系统配置

<!--DHIS2-SECTION-ID:install_database_configuration-->

The database connection information is provided to DHIS2 through a
configuration file called *dhis.conf*. Create this file and save it in
the *DHIS2\_HOME* directory. As an example this location could be:
创建配置文件示例：

    sudo -u dhis nano /home/dhis2/config/dhis.conf

A configuration file for PostgreSQL corresponding to the above setup has
these properties:

    # ----------------------------------------------------------------------
    # 数据库连接设置
    # ----------------------------------------------------------------------
    
    # Hibernate SQL 方言
    connection.dialect = org.hibernate.dialect.PostgreSQLDialect
    
    # JDBC driver class
    connection.driver_class = org.postgresql.Driver
    
    # 数据库链接 URL
    connection.url = jdbc:postgresql:dhis2db
    
    # 数据库用户名
    connection.username = postgres_dhis
    
    # 数据库密码
    connection.password = postgres_dhis
            
    # ----------------------------------------------------------------------
    # web服务设置
    # ----------------------------------------------------------------------
    
    # 如果系统部署在HTTPS服务器上，需要开启安全设置。默认值是 'off'
    # server.https = on
    
    # 指定服务程序的访问基地址 URL
    # server.base.url = http://server.com/
    

生产环境强烈建议开启*server.https* 设置，并将DHIS 2部署在加密HTTPS协议上。此设置将启用安全cookie。
 *server.base.url* 属性用于配置最终用户访问的URL地址。

> **提示**
> 
> 此配置文件支持环境变量。这意味着您可以将某些属性设置为环境变量，并由DHIS 2解析它们。例如，将数据库连接密码设置成名为“DB_PASSWD”的环境变量：
>
>	connection.password = ${DB_PASSWD}
> 


A common mistake is to have a white-space after the last property value
so make sure there is no white-space at the end of any line. Also
remember that this file contains the clear text password for your DHIS2
database so it needs to be protected from unauthorized access. To do
this invoke the following command which ensures that only the dhis user
which owns the file is allowed to read it:添加读取配置文件的权限：

    sudo chmod 0600 /home/dhis2/config/dhis.conf

### 安装Java

<!--DHIS2-SECTION-ID:install_java_installation-->

Oracle Java 8 JDK is the recommended Java option as it provides the
greatest operating system support including Ubuntu LTS 14.04. The
*webupd8team Java PPA* provides the necessary packages.

    sudo add-apt-repository ppa:webupd8team/java
    sudo apt-get update
    sudo apt-get install oracle-java8-installer

> **Note**
>
>The Oracle Java 8 JDK installer PPA has been discontinued.  Oracle downloads
>now require an Oracle account.  As an alternative, you may use the 
>OpenJDK 8 version.
>
>```
>    sudo apt-get install openjdk-8-jdk
>```

Check that your installation is okay by invoking:

    java -version

You can also ensure that the appropriate environment variables are set
by installing this package:

    sudo apt-get install oracle-java8-set-default


### Tomcat 和 DHIS2 安装

<!--DHIS2-SECTION-ID:install_tomcat_dhis2_installation-->

To install the Tomcat servlet container we will utilize the Tomcat user
package by invoking:

    sudo apt-get install tomcat8-user

此软件包可以通过以下命令帮助我们轻松的在当前目录安装一个新的Tomcat实例。最好是使用“ubuntu_dhis2”用户在home路径下安装：

    cd /home/dhis2/
    sudo tomcat8-instance-create tomcat-dhis
    sudo chown -R ubuntu_dhis2:ubuntu_dhis2: tomcat-dhis/


这将此路径下创建一个名个 *tomcat-dhis*的实例。并将实例所在tomcat-dhis目录的授给用户ubuntu_dhis2和dhis用户组。

> **提示**
> 
> 如果需要，tomcat8用户包允许创建任意数量的dhis实例。
> 

接下来编辑 */home/dhis2/tomcat-dhis/bin/setenv.sh* 文件，添加下面三行语句。
第一行命令指定Java Runtime 环境的路径，（可以通过update-alternatives --config java命令查看）
第二行命令为Tomcat为配内存，
第三行命令指定DHIS2配置文件*dhis.conf* 的路径。
Please check that the path the Java binaries are correct as they
might vary from system to system, e.g. on AMD systems you might see
*/java-8-openjdk-amd64* Note that you should adjust this to your
environment:

    export JAVA_HOME='/usr/bin/java'
    export JAVA_OPTS='-Xmx7500m -Xms4000m'
    export DHIS2_HOME='/home/dhis2/config'

Tomcat 的配置文件位于：
*/home/dhis2/tomcat-dhis/conf/server.xml*. 此文件中的*Connector*元素是定义与DHIS2连接的节点，可以通过更改port属性来指你想使用的端口号。
为了允许DHIS2前端在URLs中使用特殊字符，必须配置 *relaxedQueryChars* 属性。

    <Connector port="8080" protocol="HTTP/1.1"
      connectionTimeout="20000"
      redirectPort="8443"
      relaxedQueryChars="[]" />

接下来就是到DHISP官方下载页面（https://www.dhis2.org/downloads）下载你需要版本的 DHIS2 WAR 文件，并将其放入Tomcat的webapps目录（/home/dhis2/tomcat-dhis/webapps）。

DHIS2不应该作为特权用户运行. 所以需要在 */home/dhis2/tomcat-dhis/bin/startup.sh* 文件里修改启动脚本，将其全部内容替换为：

    #!/bin/sh
    set -e
    
    if [ "$(id -u)" -eq "0" ]; then
      echo "This script must NOT be run as root" 1>&2
      exit 1
    fi
    
    export CATALINA_BASE="/home/dhis2/tomcat-dhis"
    /usr/share/tomcat8/bin/startup.sh
    echo "Tomcat started"

### 启动并运行 DHIS2

<!--DHIS2-SECTION-ID:install_running_dhis2-->

在/home/dhis2/目录下，通过*ubuntu_dhis2*用户启动tomcat服务，DHIS2程序随即运行起来：

	sudo -u ubuntu_dhis2 ./tomcat-dhis/bin/startup.sh

> **Warning**
> 
> 绝不能使用root用户或其它特权用户来运行DHIS2 server。

通过以下命令即可停止tomcat服务：

    sudo -u ubuntu_dhis2 ./tomcat-dhis/bin/shutdown.sh

To monitor the behavior of Tomcat the log is the primary source of
information. The log can be viewed with the following command:
可以通过以下

    tail -f tomcat-dhis/logs/catalina.out

Assuming that the WAR file is called ROOT.war, you can now access your
DHIS2 instance at the following URL:

    http://localhost:8080

## 基地址 URL 配置

To set the base URL of the DHIS2 instance, you can specify the following property in the `dhis.conf` configuration file. This URL should point to the location where end users can reach DHIS2 over the network.

	server.base.url = https://play.dhis2.org/dev

## File store configuration

<!--DHIS2-SECTION-ID:install_file_store_configuration-->

DHIS2 is capable of capturing and storing files. By default files will
be stored on the file system of the server which runs DHIS2 in a *files*
directory under the *DHIS2\_HOME* external directory location.

You can also configure DHIS2 to store files on cloud-based storage
providers. Currently, AWS S3 is the only supported provider. To enable
cloud-based storage you must define the following addtional properties
in your *dhis.conf*
    file:

    # File store provider. Currently 'filesystem' and 'aws-s3' are supported.
    filestore.provider = filesystem
    
    # Directory / bucket name. Refers to subdirectory in external directory on file system and bucket on AWS S3.
    filestore.container = files
    
    # The following configuration is applicable only on non-filesystem providers (AWS S3)
    
    # Datacenter location. Not required but recommended for performance reasons.
    filestore.location = eu-west-1
    
    # Public identity / username
    filestore.identity = xxxx
    
    # Secret password (sensitive)
    filestore.secret = xxxx

This configuration is an example reflecting the defaults and should be
changed to fit your needs. In other words, you can omit it entirely if
you plan to use the default values. If you want to use an external
provider the last block of properties need to be defined, as well as the
*provider* property being set to a supported provider (currently only
AWS S3).

> **Note**
> 
> If you’ve configured cloud storage in dhis.conf, all files you upload
> or the files the system generates will use cloud storage.

For a production system the initial setup of the file store should be
carefully considered as moving files across storage providers while
keeping the integrity of the database references could be complex. Keep
in mind that the contents of the file store might contain both sensitive
and integral information and protecting access to the folder as well as
making sure a backup plan is in place is recommended on a production
implementation.

> **Note**
> 
> AWS S3 is the only supported provider (starting from version 2.27) but
> more providers are likely to be added, such as Google Cloud Store and
> Rackspace Cloud Files. Let the developers know if you have inquiries
> about adding support for more providers.

## Google service account configuration

<!--DHIS2-SECTION-ID:install_google_service_account_configuration-->

DHIS2 can connect to various Google service APIs. For instance, the
DHIS2 GIS component can utilize the Google Earth Engine API to load map
layers. In order to provide API access tokens you must set up a Google
service account and create a private key:

  - Create a Google service account. Please consult the [Google identify
    platform](https://developers.google.com/identity/protocols/OAuth2ServiceAccount#overview)
    documentation.

  - Visit the [Google cloud console](https://console.cloud.google.com)
    and go to API Manager \> Credentials \> Create credentials \>
    Service account key. Select your service account and JSON as key
    type and click Create.

  - Rename the JSON key to *dhis-google-auth.json*.

After downloading the key file, put the *dhis-google-auth.json* file in
the DHIS2\_HOME directory (the same location as the *dhis.conf* file).
As an example this location could be:

    /home/dhis/config/dhis-google-auth.json

## LDAP configuration

<!--DHIS2-SECTION-ID:install_ldap_configuration-->

DHIS2 is capable of using an LDAP server for authentication of users.
For LDAP authentication it is required to have a matching user in the
DHIS2 database per LDAP entry. The DHIS2 user will be used to represent
authorities / user roles.

To set up LDAP authentication you need to configure the LDAP server URL,
a manager user and an LDAP search base and search filter. This
configuration should be done in the main DHIS 2 configuration file
(dhis.conf). LDAP users, or entries, are identified by distinguished
names (DN from now on). An example configuration looks like this:

    # LDAP server URL
    ldap.url = ldaps://domain.org:636
    
    # LDAP manager entry distinguished name
    ldap.manager.dn = cn=johndoe,dc=domain,dc=org
    
    # LDAP manager entry password
    ldap.manager.password = xxxx
    
    # LDAP base search
    ldap.search.base = dc=domain,dc=org
    
    # LDAP search filter
    ldap.search.filter = (cn={0})

The LDAP configuration properties are explained below:

  - *ldap.url:* The URL of the LDAP server for which to authenticate
    against. Using SSL/encryption is strongly recommended in order to
    make authentication secure. As example URL is
    *ldaps://domain.org:636*, where ldaps refers to the protocol,
    *domain.org* refers to the domain name or IP address, and *636*
    refers to the port (636 is default for LDAPS).

  - *ldap.manager.dn:* An LDAP manager user is required for binding to
    the LDAP server for the user authentication process. This property
    refers to the DN of that entry. I.e. this is not the user which will
    be authenticated when logging into DHIS2, rather the user which
    binds to the LDAP server in order to do the authentication.

  - *ldap.manager.password:* The password for the LDAP manager user.

  - *ldap.search.base:* The search base, or the distinguished name of
    the search base object, which defines the location in the directory
    from which the LDAP search begins.

  - *ldap.search.filter:* The filter for matching DNs of entries in the
    LDAP directory. The {0} variable will be substituted by the DHIS2
    username, or alternatively, the LDAP identifier defined for the user
    with the supplied username.

DHIS2 will use the supplied username / password and try to authenticate
against an LDAP server entry, then look up user roles / authorities from
a corresponding DHIS2 user. This implies that a user must have a
matching entry in the LDAP directory as well as a DHIS2 user in order to
log in.

During authentication, DHIS2 will try to bind to the LDAP server using
the configured LDAP server URL and the manager DN and password. Once the
binding is done, it will search for an entry in the directory using the
configured LDAP search base and search filter.

The {0} variable in the configured filter will be substituted beforing
applying the filter. By default, it will be substituted by the supplied
username. You can also set a custom LDAP identifier on the relevant
DHIS2 user account. This can be done throught the DHIS2 user module user
interface in the add or edit screen by setting the "LDAP identifier"
property. When set, the LDAP identifier will be subsituted for the {0}
variable in the filter. This feature is useful when the LDAP common name
is not suitable or cannot for some reason be used as a DHIS2 username.

## Encryption configuration

<!--DHIS2-SECTION-ID:install_encryption_configuration-->

DHIS2 allows for encryption of data. This however requires some extra
setup.

### Java Cryptography Extension

<!--DHIS2-SECTION-ID:install_java_cryptography_extension-->

DHIS2 uses an encryption algorithm classified as strong and therefore
requires the *Java Cryptography Extension (JCE) Unlimited Strength
Jurisdiction Policy Files* to be installed. These files can be installed
through these steps:

1.  Download the JCE Unlimited Strength Jurisdiction Policy Files for
    your java version of Java from the Oracle Web site. Scroll down to
    the "Java Cryptography Extension (JCE) Unlimited Strength
    Jurisdiction Policy Files" section. It is important that the version
    of the files match the version of Java on your
    server.
    
    [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.htm)

2.  Extract the downloaded ZIP archive. It contains two JAR files:
    *local\_policy.jar* and *US\_export\_policy.jar*.

3.  Locate the JDK directory of your Java installation. From there,
    navigate into the *jre/security* directory. On Ubuntu it is often
    found at */usr/lib/jvm/java-8-oracle/jre/lib/security*.

4.  (Optional) Back up your existing *local\_policy.jar* and
    *US\_export\_policy.jar* in case you want to revert to them later.

5.  Copy the *local\_policy.jar* and *US\_export\_policy.jar* files into
    the security folder. You should now have the following files which
    completes the installation. Remember to restart your servlet
    container for it to take effect.
    
        /usr/lib/jvm/java-8-oracle/jre/lib/security/local_policy.jar
        /usr/lib/jvm/java-8-oracle/jre/lib/security/US_export_policy.jar

### Password configuration

<!--DHIS2-SECTION-ID:install_password_configuration-->

To provide security to the encryption algorithm you will have to set a
password in the *dhis.conf* configuration file through the
*encryption.password* property:

    encryption.password = xxxx

The *encryption.password* property is the password used when encrypting
and decrypting data in the database. Note that the password must not be
changed once it has been set and data has been encrypted as the data can
then no longer be decrypted. 

The password must be at least **24 characters long**. A mix of numbers 
and lower- and uppercase letters are recommended. The encryption password 
must be kept secret.

### Considerations for encryption

<!--DHIS2-SECTION-ID:install_considerations_for_encryption-->

*A word of caution:* It is not possible to recover encrypted data if the
encryption password is lost or changed. Conversely, the encryption
provides no security if the password is compromised. Hence, great
consideration should be given to storing the password in a safe place.

## Read replica database configuration

<!--DHIS2-SECTION-ID:install_read_replica_configuration-->

DHIS 2 allows for utilizing read only replicas of the master database
(the main DHIS 2 database). The purpose of read replicas is to enhance
the performance of database read queries and scale out the capacity
beyond the constraints of a single database. Read-heavy operations such
as analytics and event queries will benefit from this.

The configuration requires that you have created one or more replicated
instances of the master DHIS 2 database. PostgreSQL achieves this
through a concept referred to as *streaming replication*. Configuring
read replicas for PostgreSQL is not covered in this guide.

Read replicas can be defined in the *dhis.conf* configuration file. You
can specify up to 5 read replicas per DHIS 2 instance. Each read replica
is denoted with a number between 1 and 5. The JDBC connection URL must
be defined per replica. The username and password can be specified; if
not, the username and password for the master database will be used
instead.

The configuration for read replicas in *dhis.conf* looks like the below.
Each replica is specified with the configuration key *readN* prefix,
where N refers to the replica number.

    # Read replica 1 configuration
    
    # Database connection URL, username and password
    read1.connection.url = jdbc:postgresql://127.0.0.11/dbread1
    read1.connection.username = dhis
    read1.connection.password = xxxx
    
    # Read replica 2 configuration
    
    # Database connection URL, username and password
    read2.connection.url = jdbc:postgresql://127.0.0.12/dbread2
    read2.connection.username = dhis
    read2.connection.password = xxxx
    
    # Read replica 3 configuration
    
    # Database connection URL, fallback to master for username and password
    read3.connection.url = jdbc:postgresql://127.0.0.13/dbread3

Note that you must restart your servlet container for the changes to
take effect. DHIS 2 will automatically distribute the load across the
read replicas. The ordering of replicas has no significance.

## Web server cluster configuration

<!--DHIS2-SECTION-ID:install_web_server_cluster_configuration-->

This section describes how to set up the DHIS 2 application to run in a
cluster.

### Clustering overview

<!--DHIS2-SECTION-ID:install_cluster_configuration_introduction-->

Clustering is a common technique for improving system scalability and
availability. Clustering refers to setting up multiple web servers such
as Tomcat instances and have them serve a single application. Clustering
allows for *scaling out* an application in the sense that new servers
can be added to improve performance. It also allows for *high
availability* as the system can tolerate instances going down without
making the system inaccessible to users.

When setting up multiple Tomcat instances there is a need for making the
instances aware of each other. This awareness will enable DHIS 2 to keep
the local data (Hibernate) caches in sync and in a consistent state.
When an update is done on one instance, the caches on the other
instances must be notified so that they can be invalidated and avoid
becoming stale.

There are two aspects to configure in *dhis.conf* in order to run DHIS 2
in a cluster.

  - Each instance must specify the other DHIS 2 application members of
    the cluster.

  - An instance of the Redis data store must be installed and connection
    information must be configured for each DHIS 2 application instance.

### Cluster instance configuration

<!--DHIS2-SECTION-ID:install_cluster_configuration-->

A DHIS 2 cluster setup is based on manual configuration of each
instance. For each DHIS 2 instance one must specify the public
*hostname* as well as the hostnames of the other instances participating
in the cluster.

The hostname of the server is specified using the *cluster.hostname*
configuration property. Additional servers which participate in the
cluster are specified using the *cluster.members* configuration
property. The property expects a list of comma separated values where
each value is of the format *host:port*.

The hostname must be visible to the participating servers on the network
for the clustering to work. You might have to allow incoming and
outgoing connections on the configured port numbers in the firewall.

The port number of the server is specified using the*cluster.cache.port*
configuration property. The remote object port used for registry receive
calls is specified using *cluster.cache.remote.object.port*. Specifying
the port numbers is typically only useful when you have multiple cluster
instances on the same server / virtual machine or if you need to
explicitly specify the ports to be used so as to have them configured in
firewall. When running cluster instances on separate servers / virtual
machines it is often appropriate to use the default port number and omit
the ports configuration properties. If omitted, 4001 will be assigned as
the listener port and a random free port will be assigned as the remote
object port.

An example setup for a cluster of two web servers is described below.
For *server A* available at hostname *193.157.199.131* the following can
be specified in *dhis.conf*:

    # Cluster configuration for server A
    
    # Hostname for this web server
    cluster.hostname = 193.157.199.131
    
    # Ports for cache listener, can be omitted
    cluster.cache.port = 4001
    cluster.cache.remote.object.port = 5001
    
    # List of Host:port participating in the cluster
    cluster.members = 193.157.199.132:4001

For *server B* available at hostname *193.157.199.132* the following can
be specified in *dhis.conf* (notice how port configuration is omitted):

    # Cluster configuration for server B
    
    # Hostname for this web server
    cluster.hostname = 193.157.199.132
    
    # List of servers participating in cluster
    cluster.members = 193.157.199.131:4001

You must restart each Tomcat instance to make the changes take effect.
The two instances have now been made aware of each other and DHIS 2 will
ensure that their caches are kept in sync.

### Cluster shared data store configuration

<!--DHIS2-SECTION-ID:install_cluster_configuration_redis-->

In a cluster setup, a *Redis* instance is required and will handle
shared user sessions, application cache and cluster node leadership.

For optimum performance, *Redis Keyspace events* for _generic commands_ and _expired events_ need to be enabled in the Redis Server. If you are using a cloud platform-managed Redis server (like AWS ElastiCache for Redis or Azure Cache for Redis) you will have to enable keyspace event notifications using the respective cloud interfaces. If you are setting up a standalone Redis server, enabling keyspace event notifications can be done in the *redis.conf* file by adding or uncommenting the following line:
```
notify-keyspace-events Egx
```

DHIS2 will connect to Redis if the *redis.enabled* configuration
property in *dhis.conf* is set to *true* along with the following four
properties:

1.  *redis.host*: Specifies where the redis server is running. Defaults
    to *localhost*. Mandatory.

2.  *redis.port*: Specifies the port in which the redis server is
    listening. Defaults to *6379*. Optional.

3.  *redis.password*: Specifies the authentication password. If a password is not required it can be left blank.

4.  *redis.use.ssl*: Specifies whether the Redis server has SSL enabled. Defaults to false. Optional.
    Defaults to *false*.

When Redis is enabled, DHIS2 will automatically assign one of the
running instances as the leader of the cluster. The leader instance will
be used to execute jobs or scheduled tasks that should be run
exclusively by one instance. Optionally you can configure the
*leader.time.to.live.minutes* property in *dhis.conf* to set up how
frequently the leader election needs to occur. It also gives an
indication of how long it would take for another instance to take over
as the leader after the previous leader has shutdown/crashed. The
default value is 2 minutes. Note that assigning a leader in the cluster
is only done if Redis is enabled. An example snippet of the *dhis.conf*
configuration file with Redis enabled and leader election time
configured is shown below.

``` 
# Redis Configuration

redis.enabled = true

redis.host = 193.158.100.111

redis.port = 6379

redis.password = <your password>

redis.use.ssl = false

# Optional, defaults to 2 minutes
leader.time.to.live.minutes=4
 
```

### Load balancing

<!--DHIS2-SECTION-ID:install_load_balancing-->

With a cluster of Tomcat instances set up, a common approach for routing
incoming web requests to the backend instances participating in the
cluster is using a *load balancer*. A load balancer will make sure that
load is distributed evenly across the cluster instances. It will also
detect whether an instance becomes unavailable, and if so, stop routine
requests to that instance and instead use other available instances.

Load balancing can be achieved in multiple ways. A simple approach is
using *nginx*, in which case you will define an *upstream* element which
enumerates the location of the backend instances and later use that
element in the *proxy* location block.

``` 
http {

  # Upstream element with sticky sessions

  upstream dhis_cluster {
    ip_hash;
    server 193.157.199.131:8080;
    server 193.157.199.132:8080;
  }

  # Proxy pass to backend servers in cluster

  server {
    listen 80;

    location / {
      proxy_pass   http://dhis_cluster/;
    }
  }
}  
```

DHIS 2 keeps server-side state for user sessions to a limited degree.
Using "sticky sessions" is a simple approach to avoid replicating the
server session state by routing requests from the same client to the
same server. The *ip\_hash* directive in the upstream element ensures
this.

Note that several instructions have been omitted for brevity in the
above example. Consult the reverse proxy section for a detailed
configuration guide.

## Analytics cache configuration

<!--DHIS2-SECTION-ID:install_analytics_cache_configuration-->

DHIS 2 supports a server-side cache for analytics API responses, used by all of the analytics web apps. This cache sits within the DHIS 2 application and hence is protected by the DHIS 2 authentication and security layer. You can configure the expiration of cached entries in seconds. To enable the cache you can define the `analytics.cache.expiration` property in `dhis.conf`. The example below enabled the cache and sets expiration to one hour.

	analytics.cache.expiration = 3600


## Starting Tomcat at boot time

<!--DHIS2-SECTION-ID:install_starting_tomcat_boot_time-->

In certain situations a server might reboot unexpectedly. It is hence
preferable to have Tomcat start automatically when the server starts. To
achieve that the first step is to create init scripts. Create a new file
called `tomcat` and paste the below content into it (adjust the HOME
variable to your environment):

    #!/bin/sh
    #Tomcat init script
    
    HOME=/home/dhis/tomcat/bin
    
    case $1 in
    start)
            sh ${HOME}/startup.sh
            ;;
    stop)
            sh ${HOME}/shutdown.sh
            ;;
    restart)
            sh ${HOME}/shutdown.sh
            sleep 5
            sh ${HOME}/startup.sh
            ;;
    esac
    exit 0

Move the script to the init script directory and make them executable by
invoking:

    sudo mv tomcat /etc/init.d
    sudo chmod +x /etc/init.d/tomcat

Next make sure the tomcat init script will be invoked during system
startup and shutdown:

    sudo /usr/sbin/update-rc.d -f tomcat defaults 81

Tomcat will now be started at system startup and stopped at system
shutdown. If you later need to revert this you can replace `defaults`
with `remove` and invoke the above commands again.

## Reverse proxy configuration

<!--DHIS2-SECTION-ID:install_reverse_proxy_configuration-->

A reverse proxy is a proxy server that acts on behalf of a server. Using
a reverse proxy in combination with a servlet container is optional but
has many advantages:

  - Requests can be mapped and passed on to multiple servlet containers
    - this improves flexibility and makes it easier to run multiple
    instances of DHIS2 on the same server. It also makes it possible to
    change the internal server setup without affecting clients.

  - The DHIS2 application can be run as a non-root user on a port
    different than 80 which reduces the consequences of session
    hijacking.

  - The reverse proxy can act as a single SSL server and be configured
    to inspect requests for malicious content, log requests and
    responses and provide non-sensitive error messages which will
    improve security.

### Basic nginx setup

<!--DHIS2-SECTION-ID:install_basic_nginx_setup-->

We recommend using [nginx](http://www.nginx.org) as reverse proxy due to
its low memory footprint and ease of use. To install invoke the
following:

    sudo apt-get install nginx

nginx can now be started, reloaded and stopped with the following
commands:

    sudo /etc/init.d/nginx start
    sudo /etc/init.d/nginx reload
    sudo /etc/init.d/nginx stop

Now that we have installed nginx we will now continue to configure
regular proxying of requests to our Tomcat instance, which we assume
runs at *http://localhost:8080*. To configure nginx you can open the
configuration file by invoking:

    sudo nano /etc/nginx/nginx.conf

nginx configuration is built around a hierarchy of blocks representing
http, server and location, where each block inherit settings from parent
blocks. The following snippet will configure nginx to proxy pass
(redirect) requests from port 80 (which is the port nginx will listen on
by default) to our Tomcat instance. Include the following configuration
in nginx.conf:

    http {
      gzip on; # Enables compression, incl Web API content-types
      gzip_types
        "application/json;charset=utf-8" application/json
        "application/javascript;charset=utf-8" application/javascript text/javascript
        "application/xml;charset=utf-8" application/xml text/xml
        "text/css;charset=utf-8" text/css
        "text/plain;charset=utf-8" text/plain;
    
      server {
        listen               80;
        root  /home/dhis/tomcat/webapps/ROOT; # Update path!
        client_max_body_size 10M;
    
        # Serve static files
    
        location ~ (\.js|\.css|\.gif|\.woff|\.ttf|\.eot|\.ico|(/dhis-web-commons/|/images/|/icons/).*\.png)$ {
          add_header  Cache-Control public;
          expires     14d;
        }
    
        # Proxy pass to servlet container
    
        location / {
          proxy_pass                http://localhost:8080/;
          proxy_redirect            off;
          proxy_set_header          Host               $host;
          proxy_set_header          X-Real-IP          $remote_addr;
          proxy_set_header          X-Forwarded-For    $proxy_add_x_forwarded_for;
          proxy_set_header          X-Forwarded-Proto  http;
          proxy_buffer_size         128k;
          proxy_buffers             8 128k;
          proxy_busy_buffers_size   256k;
        }
      }
    }

You can now access your DHIS2 instance at *http://localhost*. Since the
reverse proxy has been set up we can improve security by making Tomcat
only listen for local connections. In */conf/server.xml* you can add an
*address* attribute with the value *localhost* to the Connector element
for HTTP 1.1 like this:

    <Connector address="localhost" protocol="HTTP/1.1" ... >

### Enabling SSL with nginx

<!--DHIS2-SECTION-ID:install_enabling_ssl_on_nginx-->

In order to improve security it is recommended to configure the server
running DHIS2 to communicate with clients over an encrypted connection
and to identify itself to clients using a trusted certificate. This can
be achieved through SSL which is an cryptographic communication protocol
running on top of TCP/IP. First, install the required *openssl* library:

    sudo apt-get install openssl

To configure nginx to use SSL you will need a proper SSL certificate
from an SSL provider. The cost of a certificate varies a lot depending
on encryption strength. An affordable certificate from [Rapid SSL
Online](http://www.rapidsslonline.com) should serve most purposes. To
generate the CSR (certificate signing request) you can invoke the
command below. When you are prompted for the *Common Name*, enter the
fully qualified domain name for the site you are
    securing.

    openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr

When you have received your certificate files (.pem or .crt) you will
need to place it together with the generated server.key file in a
location which is reachable by nginx. A good location for this can be
the same directory as where your nginx.conf file is located.

Below is an nginx server block where the certificate files are named
server.crt and server.key. Since SSL connections usually occur on port
443 (HTTPS) we pass requests on that port (443) on to the DHIS2 instance
running on *http://localhost:8080* The first server block will rewrite
all requests connecting to port 80 and force the use of HTTPS/SSL. This
is also necessary because DHIS2 is using a lot of redirects internally
which must be passed on to use HTTPS. Remember to replace
*\<server-ip\>* with the IP of your server. These blocks should replace
the one from the previous section.

    http {
      gzip on; # Enables compression, incl Web API content-types
      gzip_types
        "application/json;charset=utf-8" application/json
        "application/javascript;charset=utf-8" application/javascript text/javascript
        "application/xml;charset=utf-8" application/xml text/xml
        "text/css;charset=utf-8" text/css
        "text/plain;charset=utf-8" text/plain;
    
      # HTTP server - rewrite to force use of SSL
    
      server {
        listen     80;
        rewrite    ^ https://<server-url>$request_uri? permanent;
      }
    
      # HTTPS server
    
      server {
        listen               443 ssl;
        root  /home/dhis/tomcat/webapps/ROOT; # Update path!
        client_max_body_size 10M;
    
        ssl                  on;
        ssl_certificate      server.crt;
        ssl_certificate_key  server.key;
    
        ssl_session_cache    shared:SSL:20m;
        ssl_session_timeout  10m;
    
        ssl_protocols              TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers                RC4:HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;
    
        # Serve static files
    
        location ~ (\.js|\.css|\.gif|\.woff|\.ttf|\.eot|\.ico|(/dhis-web-commons/|/images/|/icons/).*\.png)$ {
          add_header  Cache-Control public;
          expires     14d;
        }
    
        # Proxy pass to servlet container
    
        location / {
          proxy_pass                http://localhost:8080/;
          proxy_redirect            off;
          proxy_set_header          Host               $host;
          proxy_set_header          X-Real-IP          $remote_addr;
          proxy_set_header          X-Forwarded-For    $proxy_add_x_forwarded_for;
          proxy_set_header          X-Forwarded-Proto  https;
          proxy_buffer_size         128k;
          proxy_buffers             8 128k;
          proxy_busy_buffers_size   256k;
        }
      }
    }

Note the last "https" header value which is required to inform the
servlet container that the request is coming over HTTPS. In order for
tomcat to properly produce Location URLs using https you also need to
add two other parameters to the Connector in tomcat's server.xml file:

    <Connector scheme="https" proxyPort="443" ... >

### Enabling caching and SSL with nginx

<!--DHIS2-SECTION-ID:install_enabling_caching_ssl_nginx-->

Requests for reports, charts, maps and other analysis-related resources
will often take some time to respond and might utilize a lot of server
resources. In order to improve response times, reduce the load on the
server and hide potential server downtime we can introduce a cache proxy
in our server setup. The cached content will be stored in directory
/var/cache/nginx, and up to 250 MB of storage will be allocated. Nginx
will create this directory automatically.

    http {
      # ...
      root              /home/dhis/tomcat/webapps/ROOT; # Update path!
      proxy_cache_path  /var/cache/nginx  levels=1:2  keys_zone=dhis:250m  inactive=1d;
    
      gzip on; # Enables compression, incl Web API content-types
      gzip_types
        "application/json;charset=utf-8" application/json
        "application/javascript;charset=utf-8" application/javascript text/javascript
        "application/xml;charset=utf-8" application/xml text/xml
        "text/css;charset=utf-8" text/css
        "text/plain;charset=utf-8" text/plain;
    
      # HTTP server - rewrite to force use of HTTPS
    
      server {
        listen     80;
        rewrite    ^ https://www.domain.com/$request_uri? permanent;
      }
    
      # HTTPS server
    
      server {
        listen               443 ssl;
        client_max_body_size 10M;
    
        ssl                  on;
        ssl_certificate      server.crt;
        ssl_certificate_key  server.key;
    
        ssl_session_timeout  30m;
    
        ssl_protocols              SSLv2 SSLv3 TLSv1;
        ssl_ciphers                HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;

    
        # Serve static files
    
        location ~ (\.js|\.css|\.gif|\.woff|\.ttf|\.eot|\.ico|(/dhis-web-commons/|/images/|/icons/).*\.png)$ {
          add_header  Cache-Control public;
          expires     14d;
        }
    
        # Proxy pass to servlet container and potentially cache response
    
        location / {
          proxy_pass                http://localhost:8080/;
          proxy_redirect            off;
          proxy_set_header          Host               $host;
          proxy_set_header          X-Real-IP          $remote_addr;
          proxy_set_header          X-Forwarded-For    $proxy_add_x_forwarded_for;
          proxy_set_header          X-Forwarded-Proto  https;
          proxy_buffer_size         128k;
          proxy_buffers             8 128k;
          proxy_busy_buffers_size   256k;
          proxy_cache               dhis;
        }
      }
    }

> **Important**
> 
> Be aware that a server side cache shortcuts the DHIS2 security
> features in the sense that requests which hit the server side cache
> will be served directly from the cache outside the control of DHIS2
> and the servlet container. This implies that request URLs can be
> guessed and reports retrieved from the cache by unauthorized users.
> Hence, if you capture sensitive information, setting up a server side
> cache is not recommended.

### Rate limiting with nginx

<!--DHIS2-SECTION-ID:install_rate_limiting-->

Certain web API calls in DHIS 2, like the `analytics` APIs, are compute intensive. As a result it is favorable to rate limit these APIs in order to allow all users of the system to utilize a fair share of the server resources. Rate limiting can be achieved with `nginx`. There are numerous approaches to achieving rate limiting and this is intended to document the nginx-based approach.

The below nginx configuration will rate limit the `analytics` web API, and has the following elements at the *http* and *location* block level (the configuration is shortened for brevity):

````
http {
  ..
  limit_req_zone $binary_remote_addr zone=limit_analytics:10m rate=5r/s;

  server {
    ..
        
    location ~ ^/api/(\d+/)?analytics(.*)$ {
      limit_req    zone=limit_analytics burst=20;
      proxy_pass   http://localhost:8080/api/$1analytics$2$is_args$args;
      ..
    }
  }
}
````

The various elements of the configuration can be described as:

- *limit_req_zone $binary_remote_addr*: Rate limiting is done per request IP.
- *zone=limit_analytics:20m*: A rate limit zone for the analytics API which can hold up to 10 MB of request IP addresses.
- *rate=20r/s*: Each IP is granted 5 requests per second.
- *location ~ ^/api/(\d+/)?analytics(.\*)$*: Requests for the analytics API endpoint are rate limited.
- *burst=20*: Bursts of up to 20 requests will be queued and serviced at a later point; additional requests will lead to a `503`.

For a full explanation please consult the [nginx documentation](https://www.nginx.com/blog/rate-limiting-nginx/).

### Additional resources on SSL

<!--DHIS2-SECTION-ID:install_additional_resources_ssl-->

The configuration demonstrated above should be regarded as the absolute
minumum in order to establish a secure server. However, encryption
methods are constantly being updated, so implementers who are
administerting their own server, show ensure that the server is
regularly updated with recent security patches (particularly the HTTP
server and SSL libraries).

There are numerous additional tutorials and information available on the
web, including a helpful [step-by-step
guide](https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-16-04)
for using the free [Lets Encrypt SSL certifcate
system](https://letsencrypt.org/) . It may also be useful to regularly
test your SSL security with [this
website](https://www.ssllabs.com/ssltest/).

### Making resources available with nginx

<!--DHIS2-SECTION-ID:install_making_resources_available_with_nginx-->

In some scenarios it is desirable to make certain resources publicly
available on the Web without requiring authentication. One example is
when you want to make data analysis related resources in the Web API
available in a Web portal. The following example will allow access to
charts, maps, reports, report table and document resources through basic
authentication by injecting an *Authorization* HTTP header into the
request. It will remove the Cookie header from the request and the
Set-Cookie header from the response in order to avoid changing the
currently logged in user. It is recommended to create a user for this
purpose given only the minimum authorities required. The Authorization
value can be constructed by Base64-encoding the username appended with a
colon and the password and prefix it "Basic ", more precisely "Basic
base64\_encode(username:password)". It will check the HTTP method used
for requests and return *405 Method Not Allowed* if anything but GET is
detected.

It can be favorable to set up a separate domain for such public users
when using this approach. This is because we don't want to change the
credentials for already logged in users when they access the public
resources. For instance, when your server is deployed at somedomain.com,
you can set a dedicated subdomain at api.somedomain.com, and point URLs
from your portal to this subdomain.

    server {
      listen       80;
      server_name  api.somedomain.com;
        
      location ~ ^/(api/(charts|chartValues|reports|reportTables|documents|maps|organisationUnits)|dhis-web-commons/javascripts|images|dhis-web-commons-ajax-json|dhis-web-mapping|dhis-web-visualizer) {
        if ($request_method != GET) {
          return 405;
        }
    
        proxy_pass         http://localhost:8080;
        proxy_redirect     off;
        proxy_set_header   Host               $host;
        proxy_set_header   X-Real-IP          $remote_addr;
        proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto  http;
        proxy_set_header   Authorization      "Basic YWRtaW46ZGlzdHJpY3Q=";
        proxy_set_header   Cookie             "";
        proxy_hide_header  Set-Cookie;
      }
    }

### Basic reverse proxy setup with Apache

<!--DHIS2-SECTION-ID:install_basic_reverse_proxy_setup_with_apache-->

The Apache HTTP server is the most common

> **Important**
> 
> Using nginx is the preferred option as reverse proxy with DHIS2 and
> you should not attempt to install both nginx and Apache on the same
> server. If you have installed nginx please ignore this section.

The Apache HTTP server is the most widely used HTTP server currently.
Depdenign on your exact nature of deployment, you may need to use Apache
as a reverse proxy for your DHIS2 server. In this section, we will
describe how to implement a simple reverse proxy setup with Apache.

First we need to install a few necessary programs modules for Apache and
enable the
    modules.

    sudo apt-get install apache2 libapache2-mod-proxy-html libapache2-mod-jk
    a2enmod proxy proxy_ajp proxy_connect

Lets define an AJP connector which Apache HTTP server will use to
connect to Tomcat with. The Tomcat `server.xml` file should be located
in the /conf/ director of your Tomcat installation. Be sure this line is
uncommented.You can set the port to anything you like which is unused.

    <Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />

Now, we need to make the adjustments to the Apache HTTP server which
will answer requests on port 80 and pass them to the Tomcat server
through an AJP connector. Edit the file
`/etc/apache2/mods-enabled/proxy.conf` so that it looks like the example
below. Be sure that the port defined in the configuration file matches
the one from Tomcat.

    <IfModule mod_proxy.c>
    
    ProxyRequests Off
    ProxyPass /dhis  ajp://localhost:8009/dhis
    ProxyPassReverse /dhis  ajp://localhost:8009/dhis
    
    <Location "/dhis">
      Order allow,deny
      Allow from all
    </Location>     
    </IfModule>

You now can restart Tomcat and the Apache HTTPD server and your DHIS2
instance should be available on http://*myserver*/dhis where *myserver*
is the hostname of your server.

### SSL encryption with Apache

<!--DHIS2-SECTION-ID:install_ssl_encryption_with_apache-->

Using Apache and the reverse proxy setup described in the previous
section, we can easily implement encrypted transfer of data between
clients and the server over HTTPS. This section will describe how to use
self-signed certificates, although the same procedure could be used if
you have fully-signed certificates as well.

First (as root), generate the necessary private key files and CSR
(Certificate Signing Request)

    mkdir /etc/apache2/ssl
    cd /etc/apache2/ssl
    openssl genrsa -des3 -out server.key 1024
    openssl req -new -key server.key -out server.csr

We need to remove the password from the key, otherwise Apache will not
be able to use it.

    cp server.key server.key.org
    openssl rsa -in server.key.org -out server.key

Next, generate a self-signed certificate which will be valid for one
year.

    openssl x509 -req -days 365 -in server.csr -signkey \ server.key -out server.crt

Now, lets configure Apache by enabling the SSL modules and creating a
default site.

    a2enmod ssl
    a2ensite default-ssl

Now, we need to edit the default-ssl (located at
`/etc/apache2/sites-enabled/default-ssl`) file in order to enable the
SSL transfer functionality of Apache.

    <VirtualHost *:443>
            ServerAdmin wemaster@mydomain.org
           SSLEngine On
           SSLCertificateFile /etc/apache2/ssl/server.crt
           SSLCertificateKeyFile /etc/apache2/ssl/server.key
    ...

Be sure that the \*:80 section of this file is changed to port \*:443,
which is the default SSL port. Also, be sure to change the ServerAdmin
to the webmaster's email. Lastly, we need to be sure that the hostname
is setup properly in /etc/hosts. Just under the "localhost" line, be
sure to add the server's IP address and domain name.

    127.0.0.1 localhost
    XXX.XX.XXX.XXX foo.mydomain.org

Now, just restart Apache and you should be able to view
https://foo.mydomain.org/dhis.

    /etc/init.d/apache2 restart

## DHIS2 configuration reference

<!--DHIS2-SECTION-ID:install_dhis2_configuration_reference-->

The following describes the full set of configuration options for the *dhis.conf* configuration file. The uncommented properties are mandatory. The commented properties are optional. The configuration file should be placed in a directory which is pointed to by a *DHIS2\_HOME* environment variable. The comment (\#) must be removed for a property value to take effect. You can copy and paste the following content as a viable starting point for your own configuration file.

    # ----------------------------------------------------------------------
    # Database connection for PostgreSQL
    # ----------------------------------------------------------------------
    
    # Hibernate SQL dialect
    connection.dialect = org.hibernate.dialect.PostgreSQLDialect
    
    # JDBC driver class
    connection.driver_class = org.postgresql.Driver
    
    # Database connection URL
    connection.url = jdbc:postgresql:dhis2
    
    # Database username
    connection.username = dhis
    
    # Database password (sensitive)
    connection.password = xxxx
    
    # Database schema behavior, can be 'validate', 'update', 'create', 'create-drop'
    connection.schema = update
    
    # Max size of connection pool (default: 40)
    # connection.pool.max_size = 40
    
    # ----------------------------------------------------------------------
    # Server
    # ----------------------------------------------------------------------
    
    # Base URL to the DHIS 2 instance
    # server.base.url = https://play.dhis2.org/dev 
    
    # Enable secure settings if system is deployed on HTTPS, can be 'off', 'on'
    # server.https = on
    
    # ----------------------------------------------------------------------
    # System
    # ----------------------------------------------------------------------
    
    # System mode for database read operations only, can be 'off', 'on'
    # system.read_only_mode = off
    
    # Session timeout in seconds, default is 3600
    # system.session.timeout = 3600
    
    # SQL view protected tables, can be 'on', 'off'
    # system.sql_view_table_protection = on
    
    # ----------------------------------------------------------------------
    # Encryption
    # ----------------------------------------------------------------------
    
    # Encryption password (sensitive)
    # encryption.password = xxxx
    
    # ----------------------------------------------------------------------
    # File store
    # ----------------------------------------------------------------------
    
    # File store provider, currently 'filesystem' and 'aws-s3' are supported
    # filestore.provider = filesystem
    
    # Directory / bucket name, refers to folder within DHIS2_HOME on file system, 'bucket' on AWS S3
    # filestore.container = files
    
    # Datacenter location (not required)
    # filestore.location = eu-west-1
    
    # Public identity / username
    # filestore.identity = dhis2-id
    
    # Secret key / password (sensitive)
    # filestore.secret = xxxx
    
    # ----------------------------------------------------------------------
    # LDAP
    # ----------------------------------------------------------------------
    
    # LDAP server URL
    # ldap.url = ldaps://300.20.300.20:636
    
    # LDAP manager user distinguished name
    # ldap.manager.dn = cn=JohnDoe,ou=Country,ou=Admin,dc=hisp,dc=org
    
    # LDAP manager user password (sensitive)
    # ldap.manager.password = xxxx
    
    # LDAP entry distinguished name search base
    # ldap.search.base = dc=hisp,dc=org
    
    # LDAP entry distinguished name filter
    # ldap.search.filter = (cn={0})
    
    # ----------------------------------------------------------------------
    # Node
    # ----------------------------------------------------------------------
    
    # Node identifier, optional, useful in clusters
    # node.id = 'node-1'
    
    # ----------------------------------------------------------------------
    # Analytics
    # ----------------------------------------------------------------------
    
    # Analytics server-side cache expiration in seconds
    # analytics.cache.expiration = 3600
    
    # ----------------------------------------------------------------------
    # System monitoring
    # ----------------------------------------------------------------------
    
    # System monitoring URL
    # system.monitoring.url = 
    
    # System monitoring username
    # system.monitoring.username = 
    
    # System monitoring password
    # system.monitoring.password =

## Application logging

<!--DHIS2-SECTION-ID:install_application_logging-->

This section covers application logging in DHIS 2.

### Log files

The DHIS2 application log output is directed to multiple files and locations. First, log output is sent to standard output. The Tomcat servlet container usually outputs standard output to a file under "logs":

    <tomcat-dir>/logs/catalina.out

Second, log output is written to a "logs" directory under the DHIS2 home directory as defined by the the DHIS2\_HOME environment variables. There is a main log file for all output, and separate log files for various
background processes. The main file includes the background process logs as well. The log files are capped at 50 Mb and log content is continuously appended.

    <DHIS2_HOME>/logs/dhis.log    
    <DHIS2_HOME>/logs/dhis-analytics-table.log
    <DHIS2_HOME>/logs/dhis-data-exchange.log
    <DHIS2_HOME>/logs/dhis-data-sync.log

### Log configuration

In order to override the default log configuration you can specify a Java system property with the name *log4j.configuration* and a value pointing to the Log4j configuration file on the classpath. If you want to point to a
file on the file system (i.e. outside Tomcat) you can use the *file* prefix e.g. like this:

    -Dlog4j.configuration=file:/home/dhis/config/log4j.properties

Java system properties can be set e.g. through the *JAVA\_OPTS* environment variable or in the tomcat startup script.

A second approach to overriding the log configuration is to specify logging properties in the *dhis.conf* configuration file. The supported properties are:

	# Max size for log files, default is '100MB'
	logging.file.max_size = 250MB
	
	# Max number of rolling log archive files, default is 0
	logging.file.max_archives = 2

DHIS2 will eventually phase out logging to standard out / catalina.out and as a result it is recommended to rely on the logs under DHIS2\_HOME.

## Working with the PostgreSQL database

<!--DHIS2-SECTION-ID:install_working_with_the_postgresql_database-->

Common operations when managing a DHIS2 instance are dumping and
restoring databases. To make a dump (copy) of your database, assuming
the setup from the installation section, you can invoke the following:

    pg_dump dhis2 -U dhis -f dhis2.sql

The first argument (dhis2) refers to the name of the database. The
second argument (dhis) refers to the database user. The last argument
(dhis2.sql) is the file name of the copy. If you want to compress the
file copy immediately you can do:

    pg_dump dhis2 -U dhis | gzip > dhis2.sql.gz

To restore this copy on another system, you first need to create an
empty database as described in the installation section. You also need
to gunzip the copy if you created a compressed version. You can the
invoke:

    psql -d dhis2 -U dhis -f dhis2.sql

## DHIS2 Live setup

<!--DHIS2-SECTION-ID:install_dhis2_live_setup-->

The DHIS2 Live package is extremely convenient to install and run. It is
intended for demonstrations, for users who want to explore the system
and for small, offline installations typically at districts or
facilities. It only requires a Java Runtime Environment and runs on all
browsers except Internet Explorer 7 and lower.

To install start by downloading DHIS2 Live from *http://dhis2.org* and
extract the archive to any location. On Windows click the executable
archive. On Linux invoke the startup.sh script. After the startup
process is done your default web browser will automtically be pointed to
*http://localhost:8082* where the application is accessible. A system
tray menu is accessible on most operating systems where you can start
and stop the server and start new browser sesssions. Please note that if
you have the server running there is no need to start it again, simply
open the application from the tray menu.

DHIS2 Live is running on an embedded Jetty servlet container and an
embedded H2 database. However it can easily be configured to run on
other database systems such as PostgreSQL. Please read the section above
about server installations for an explanation of the database
configuration. The *dhis.conf* configuration file is located in the
*conf* folder. Remember to restart the Live package for your changes to
take effect. The server port is 8082 by default. This can be changed by
modifying the value in the*jetty.port* configuration file located in the
*conf* directory.

